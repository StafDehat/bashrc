#!/bin/bash

#
# Upload a file to Cloud Files.  If it's over 4GB, split into 1GB chunks.

. $BASHRC_BASE/bashrc/errors.bash

function usage() {
  echo "Usage: brc-files-uploadfile [-h] [-a BRC_AUTHTOKEN] [-r BRC_REGION] \\"
  echo "                            [-t BRC_TENANTID] [-v BRC_VAULTNAME] \\"
  echo "                            -f LOCALFILE -c CONTAINER \\"
  echo "                            -n NEWFILENAME"
  echo "Example:"
  echo "  # brc-files-uploadfile -a 1a2b3c4d5e6f7g8h9i0j \\"
  echo "                         -t 123456 \\"
  echo "                         -v MossoCloudFS_199f2dd2-e293-11e3-87ea-6f46a026e216 \\"
  echo "                         -r dfw \\"
  echo "                         -f /home/user/pbjt.jpg \\"
  echo "                         -c jpegs"
  echo "Arguments:"
  echo "  -a X	Authentication token.  This can be set via the environment"
  echo "        variable BRC_AUTHTOKEN instead of as an argument."
  echo "  -c X  Name of Cloud Files container in which to store file."
  echo "  -f X  Path to local file to be uploaded."
  echo "  -h	Print this help"
  echo "  -n X  Optional.  Filename to use in Cloud Files.  If excluded,"
  echo "        name in Cloud Files will match local filename."
  echo "  -r X  Region.  Examples: iad, dfw, ord, syd.  This can be set via"
  echo "        the environment variable BRC_REGION instead of as an"
  echo "        argument."
  echo "  -v X  Vault name for this account.  This can be set via the environment"
  echo "        variable BRC_VAULTNAME instead of as an argument."
}

USAGEFLAG=0
while getopts ":a:c:f:hn:r:v:" arg; do
  case $arg in
    a) BRC_AUTHTOKEN=$OPTARG;;
    c) CONTAINER=$OPTARG;;
    f) LOCALFILE="$OPTARG";;
    h) usage && exit 0;;
    n) NEWFILENAME="$OPTARG";;
    r) BRC_REGION=$OPTARG;;
    v) BRC_VAULTNAME=$OPTARG;;
    :) echo "ERROR: Option -$OPTARG requires an argument."
       USAGEFLAG=1;;
    *) echo "ERROR: Invalid option: -$OPTARG"
       USAGEFLAG=1;;
  esac
done #End arguments
shift $(($OPTIND - 1))

if [ -z "$BRC_AUTHTOKEN" ]; then
  echo "ERROR: Must define BRC_AUTHTOKEN in environment or argument"
  USAGEFLAG=1
fi
if [ -z "$BRC_REGION" ]; then
  echo "ERROR: Must define BRC_REGION in environment or argument"
  USAGEFLAG=1
fi
if [ -z "$LOCALFILE" ]; then
  echo "ERROR: Must define LOCALFILE as argument"
  USAGEFLAG=1
elif [ ! -f "$LOCALFILE" ]; then
  echo "ERROR: Can not access $LOCALFILE - does it exist?"
  USAGEFLAG=1
fi
if [ -z "$CONTAINER" ]; then
  echo "ERROR: Must define CONTAINER as argument"
  USAGEFLAG=1
fi
if [ -z "$BRC_VAULTNAME" ]; then
  echo "ERROR: Must define BRC_VAULTNAME in environment or argument"
  USAGEFLAG=1
fi

if [ $USAGEFLAG -ne 0 ]; then
  usage && exit 1
fi

FILES_ENDPOINT=$( $BRCUTIL/brc-util-filesendpoint -r $BRC_REGION )
#CDN_ENDPOINT=$( $BRCUTIL/brc-util-cdnendpoint -r $BRC_REGION )

if [ -z "$NEWFILENAME" ]; then
  NEWFILENAME=$( basename "$LOCALFILE" )
fi


function uploadSmallFile() {
  local FILE="$1"
  local CFNAME="$2"
  local MD5="$3"
  DATA=$( curl --write-out \\n%{http_code} --silent --output - \
               $FILES_ENDPOINT/$BRC_VAULTNAME/$CONTAINER/$CFNAME \
               -T <( cat "$FILE" ) \
               -X PUT \
               -H "X-Auth-Token: $BRC_AUTHTOKEN" \
               -H "ETag: $MD5" \
            2>/dev/null )
  RETVAL=$?
  CODE=$( echo "$DATA" | tail -n 1 )
  # Check for failed API call
  if [ $RETVAL -ne 0 ]; then
    errorcurlfail
  elif [[ $(echo "$CODE" | grep -cE '^2..$') -eq 0 ]]; then
    errornot200 $CODE $( echo "$DATA" | head -n -1 )
  fi
}


function uploadLargeFile() {
  local FILE="$1"
  local CFNAME="$2"
  local SIZE=$( du -B 1G "$FILE" | awk '{print $1}' )
  for COUNT in $( seq -w 0 $(( $SIZE - 1 )) ); do
    # bs=4096 -- Attempt to optimize read speeds by matching block size on drive architecture
    # count=262144 == 1G/4096 -- Read 1G
    # skip=262144 * $COUNT -- Skip previously-read 1G chunks
    local MD5=$( dd if="$FILE" bs=4k count=262144 seek=$(( 262144 * $COUNT )) \
                   | md5sum | awk '{print $1}' )
    uploadSmallFile <( dd if="$FILE" bs=4k count=262144 seek=$(( 262144 * $COUNT )) ) \
                    ${CFNAME}-$COUNT \
                    $MD5
  done

  # Create/Upload an empty dynamic manifest file
  DATA=$( curl --write-out \\n%{http_code} --silent --output - \
               $FILES_ENDPOINT/$BRC_VAULTNAME/$CONTAINER/$CFNAME \
               -T /dev/null \
               -X PUT \
               -H "X-Auth-Token: $BRC_AUTHTOKEN" \
               -H "X-Object-Manifest: $CONTAINER/${CFNAME}-" \
            2>/dev/null )
  RETVAL=$?
  CODE=$( echo "$DATA" | tail -n 1 )
  # Check for failed API call
  if [ $RETVAL -ne 0 ]; then
    errorcurlfail
  elif [[ $(echo "$CODE" | grep -cE '^2..$') -eq 0 ]]; then
    errornot200 $CODE $( echo "$DATA" | head -n -1 )
  fi
  DATA=$( echo "$DATA" | head -n -1 | $BRCUTIL/brc-util-json.tool )
}


#
# Test the source file.
# If > 4G then split & upload each piece individually, then create a dynamic manifest
# http://docs.rackspace.com/files/api/v1/cf-devguide/content/Large_Object_Creation-d1e2019.html
#
MAXSIZE=$(( 4 * 1024 * 1024 * 1024 ))
MAXSIZE=$(( 1 * 1024 * 1024 * 1024 ))
if [ $( stat -c%s "$LOCALFILE" ) -lt $MAXSIZE ]; then
  # Just upload it.  Function this.
  MD5=$( md5sum "$LOCALFILE" | awk '{print $1}' )
  uploadSmallFile "$LOCALFILE" "$NEWFILENAME" "$MD5"
else
  uploadLargeFile "$LOCALFILE" "$NEWFILENAME"
fi

echo "Data:"
echo "$DATA"
exit 0
